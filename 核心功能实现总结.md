# 刷题软件项目核心功能实现总结

## 1. 用户认证功能

### 功能描述：实现用户注册和登录功能

#### 核心代码位置：app.py 第172-260行

**关键实现**：
- `register_user()` (第218-238行)：处理用户注册逻辑
- `login_in()` (第239-258行)：处理用户登录逻辑

```python
# 用户注册功能实现 (部分代码)
def register_user(self):
    username = self.ui.lineEdit.text()
    pwd = self.ui.lineEdit_2.text()
    confirm_pwd = self.ui.lineEdit_3.text()
    if not all([username, pwd, confirm_pwd]):
        QMessageBox.warning(self, "警告", "所有字段都必须填写")
        return
    if pwd != confirm_pwd:
        QMessageBox.warning(self, "警告", "两次输入的密码不一致")
        return
    hashed_pwd = utils.hash_password(pwd)
    if db.add_user(username, hashed_pwd):
        QMessageBox.information(self, "提示", "注册成功")
        self.ui.stackedWidget_2.setCurrentIndex(0)
    else:
        QMessageBox.warning(self, "警告", "用户名已存在")

# 用户登录功能实现 (部分代码)
def login_in(self):
    username = self.ui.lineEdit_4.text()
    pwd = self.ui.lineEdit_5.text()
    if not all([username, pwd]):
        QMessageBox.warning(self, "警告", "用户名和密码都必须填写")
        return
    user = db.get_user(username)
    if user and utils.verify_password(pwd, user['password']):
        self.close()
        self.main_window = MainWindow(user['id'], username)
        self.main_window.show()
    else:
        QMessageBox.warning(self, "警告", "用户名或密码错误")
```

## 2. 题库管理功能

### 功能描述：实现题目导入、加载和筛选功能

#### 核心代码位置：
- app.py 第46-170行：TXT题目解析
- app.py 第1259-1323行：文件导入功能
- db.py 第76-145行：数据库操作

**关键实现**：
- `parse_txt_questions()` (app.py 第46-170行)：解析TXT格式题目
- `confirm_import()` (app.py 第1267-1323行)：确认导入题目
- `import_questions_from_json_file()` (db.py 第76-103行)：导入JSON格式题目

```python
# 题目导入功能实现 (部分代码)
def confirm_import(self):
    if not self.file_path:
        QMessageBox.warning(self, "警告", "请先选择文件")
        return
    try:
        if self.file_path.endswith('.json'):
            count = db.import_questions_from_json_file(self.file_path)
            QMessageBox.information(self, "提示", f"成功导入 {count} 道题目")
        elif self.file_path.endswith('.txt'):
            questions = parse_txt_questions(self.file_path)
            if questions:
                count = db.import_questions(questions)
                QMessageBox.information(self, "提示", f"成功导入 {count} 道题目")
            else:
                QMessageBox.warning(self, "警告", "文件格式错误或没有有效题目")
        else:
            QMessageBox.warning(self, "警告", "仅支持 JSON 和 TXT 格式的题目文件")
        self.refresh_wrong_list()
    except Exception as e:
        QMessageBox.critical(self, "错误", f"导入失败：{e}")
```

## 3. 练习功能

### 功能描述：实现题目练习、答题和答案提交功能

#### 核心代码位置：app.py 第715-1077行

**关键实现**：
- `start_practice()` (第715-777行)：开始常规练习
- `show_question()` (第805-853行)：显示题目
- `next_question()` (第1037-1077行)：切换到下一题

```python
# 开始练习功能实现 (部分代码)
def start_practice(self, unit: int = None, subject: str = None, shuffle: bool = False):
    try:
        use_subject = subject if subject is not None else self.selected_subject
        if use_subject is None:
            QMessageBox.information(self, "提示", "请先选择科目")
            return
        use_unit = unit if unit is not None else None
        filtered = db.load_questions_filtered(subject=use_subject, unit=use_unit)
        if not filtered:
            QMessageBox.information(self, "提示", "本单元暂无题目，请先导入或选择其他单元")
            return
        if shuffle:
            random.shuffle(filtered)
        maxq = getattr(self, "max_questions", 10)
        if len(filtered) > maxq:
            filtered = filtered[:maxq]
        self.questions = filtered
        self.cur_index = 0
        self.finished = False
        self.in_wrong_mode = False
        self.show_question(0)
        self._update_nav_buttons_state()
    except Exception as e:
        logging.exception("start_practice unhandled")
        QMessageBox.critical(self, "错误", f"开始练习失败（已记录）：{e}")
```

## 4. 答案提交与评分功能

### 功能描述：实现答案提交、正确性判断和解析显示

#### 核心代码位置：app.py 第1078-1240行

**关键实现**：
- `submit_current_answer()` (第1078-1239行)：提交当前答案

```python
# 答案提交功能实现 (部分代码)
def submit_current_answer(self):
    try:
        q = getattr(self, "current_q", None)
        if q is None:
            QMessageBox.information(self, "提示", "当前没有题目")
            return
        widgets = getattr(self, "current_option_widgets", None)
        if not widgets:
            QMessageBox.warning(self, "提示", "未检测到选项控件")
            return
        selected = []
        correct_flag = False
        qtype = (q.get("type") or "single").lower()
        
        # 处理单选题
        if qtype == "single":
            # ... 单选题处理逻辑 ...
            normalized_sel = [s.strip().upper() for s in selected if s]
            normalized_ans = [a.strip().upper() for a in (q.get("answer") or [])]
            correct_flag = (normalized_ans and normalized_sel and normalized_sel[0] in normalized_ans)
            
        # 处理多选题
        elif qtype == "multi":
            # ... 多选题处理逻辑 ...
            normalized_sel = set([s.strip().upper() for s in selected if s])
            normalized_ans = set([a.strip().upper() for a in (q.get("answer") or [])])
            correct_flag = (len(normalized_ans) > 0 and normalized_sel == normalized_ans)
            
        # 记录答案到数据库
        db.record_user_answer(self.user_id, q['id'], selected, correct_flag)
        self.refresh_wrong_list(limit=self.max_questions)
        
        # 显示答案解析
        ans_list = q.get("answer") or []
        ans_html = "<b>答案：</b> " + (", ".join(ans_list) if isinstance(ans_list, (list,tuple)) else str(ans_list)) + "<br/><br>"
        ans_html += "<b>解析：</b><br/>" + (q.get("analysis") or "无解析")
        # ... 显示解析的UI处理 ...
        
        self.update_statistics_display()
    except Exception as e:
        traceback.print_exc()
        QMessageBox.critical(self, "错误", f"提交答案时发生内部错误：{e}")
```

## 5. 错题本功能

### 功能描述：实现错题记录、错题查看和错题练习功能

#### 核心代码位置：app.py 第564-644行

**关键实现**：
- `refresh_wrong_list()` (第564-610行)：刷新错题列表
- `start_wrong_practice()` (第645-714行)：开始错题练习

```python
# 刷新错题列表功能实现 (部分代码)
def refresh_wrong_list(self, limit: int = None):
    try:
        wrong_qs = db.get_wrong_questions(self.user_id, limit)
        if not hasattr(self.ui, "listWidget_wrong"):
            return
        lw = self.ui.listWidget_wrong
        lw.clear()
        self.wrong_questions = wrong_qs
        for i, q in enumerate(wrong_qs):
            try:
                qid = q.get("id")
                stem = q.get("stem", "") or ""
                if len(stem) > 100:
                    stem = stem[:97] + "..."
                item = QtWidgets.QListWidgetItem(stem)
                item.setData(QtCore.Qt.UserRole, i)
                lw.addItem(item)
            except Exception:
                continue
    except Exception as e:
        logging.exception("refresh_wrong_list")
        QMessageBox.critical(self, "错误", f"加载错题本失败：{e}")

# 错题练习功能实现 (部分代码)
def start_wrong_practice(self, limit: int = None, shuffle: bool = False):
    try:
        wrong_qs = db.get_wrong_questions(self.user_id, limit)
        if not wrong_qs:
            QMessageBox.information(self, "提示", "错题本为空")
            return
        if shuffle:
            random.shuffle(wrong_qs)
        self.questions = wrong_qs
        self.cur_index = 0
        self.finished = False
        self.in_wrong_mode = True
        self.show_question(0)
        self._update_nav_buttons_state()
    except Exception as e:
        logging.exception("start_wrong_practice")
        QMessageBox.critical(self, "错误", f"开始错题练习失败：{e}")
```

## 6. 统计功能

### 功能描述：实现答题统计和正确率显示

#### 核心代码位置：app.py 第1240行附近

**关键实现**：
- `update_statistics_display()`：更新统计信息显示

## 7. 界面管理功能

### 功能描述：实现界面切换和布局管理

#### 核心代码位置：
- InterfaceUi.py：实现主界面UI
- LoginUi.py：实现登录界面UI

**关键实现**：
- 使用PyQt5的stackedWidget实现页面切换
- 各种按钮点击事件绑定

## 8. 数据库操作功能

### 功能描述：实现数据持久化和查询

#### 核心代码位置：db.py

**关键实现**：
- 用户管理：`add_user()`, `get_user()`
- 题目管理：`import_questions()`, `load_questions_filtered()`
- 答题记录：`record_user_answer()`
- 错题管理：`get_wrong_questions()`

```python
# 数据库操作核心代码示例 (db.py)
def record_user_answer(user_id, question_id, user_answer, is_correct):
    try:
        conn = _get_conn()
        c = conn.cursor()
        # 记录答题历史
        c.execute(
            "INSERT INTO user_answers (user_id, question_id, user_answer, is_correct, created_at) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)",
            (user_id, question_id, json.dumps(user_answer), is_correct)
        )
        # 处理错题
        if is_correct:
            c.execute("DELETE FROM wrong_questions WHERE user_id = ? AND question_id = ?", (user_id, question_id))
        else:
            c.execute(
                "INSERT OR IGNORE INTO wrong_questions (user_id, question_id, added_at) VALUES (?, ?, CURRENT_TIMESTAMP)",
                (user_id, question_id)
            )
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        logging.exception("record_user_answer")
        return False
```